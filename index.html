// Add this helper function to maintain fluidity during complex raking
function resample(drop) {
    const maxDist = 4; // Threshold to inject new detail
    const newVertices = [];
    
    for (let i = 0; i < drop.vertices.length; i++) {
        let v1 = drop.vertices[i];
        let v2 = drop.vertices[(i + 1) % drop.vertices.length];
        
        newVertices.push(v1);
        
        // Calculate distance between points
        let d = Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2);
        
        // If they are too far apart, add a midpoint
        if (d > maxDist) {
            newVertices.push({
                x: (v1.x + v2.x) / 2,
                y: (v1.y + v2.y) / 2
            });
        }
    }
    drop.vertices = newVertices;
}

// Update the applyTine logic to trigger resampling
function applyTine(x, y, dx, dy, radius) {
    drops.forEach(drop => {
        let moved = false;
        drop.vertices.forEach(v => {
            let distSq = (x - v.x)**2 + (y - v.y)**2;
            if (distSq < radius * radius) {
                let force = Math.pow(1 - Math.sqrt(distSq) / radius, 1.5);
                v.x += dx * force * 1.5;
                v.y += dy * force * 1.5;
                moved = true;
            }
        });
        // If the drop was touched by the rake, check if it needs more detail
        if (moved) resample(drop);
    });
}
